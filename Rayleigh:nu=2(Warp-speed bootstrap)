
# ============================================================
# Unified Simulation for Chi-family Tests (Rayleigh:nu=2) 
# Warp-speed bootstrap
# Author: Ganesh Avhad
# ============================================================

library(stats4); library(VGAM); library(extraDistr); library(actuar); library(evd)

# ========== Target Distribution ========== #
rchi_family <- function(n, nu, sigma = 1) {
  return(sigma * sqrt(rchisq(n, df = nu)))
}

pchi_family <- function(x, nu, sigma = 1) {
  return(pchisq((x / sigma)^2, df = nu))
}
# Random number generation for Rayleigh distribution
rrayleigh <- function(n, parm) {
  return(sqrt(-2 * parm^2 * log(runif(n))))
}

# Cumulative distribution function for Rayleigh distribution
prayleigh <- function(x, parm) {
  return(1 - exp(- (x / parm)^2 / 2))
}

# ========== Parameter Estimation ========== #
estimation <- function(x) sqrt(mean(x^2) / nu)

# ========== Test Statistics ========== #
Tn <- function(X, parm, a, nu) {
  data = X / parm
  n = length(data)
  mdata = matrix(data, n, n)
  pdata = mdata + t(mdata) + a
  multdata = (nu - 1 - mdata^2) * t(nu - 1 - mdata^2)
  SUM = 2 / pdata^3 - 2 * (nu - 1 - mdata^2) / (mdata * pdata^2) + multdata / (mdata * t(mdata) * pdata)
  sum(SUM) / n
}


## Baratpour and Khodadadi test statistic
CKn <- function(X, parm, nu) {
  # Sort the data
  X1<- X / parm  
  X <- sort(X1)
  n <- length(X)
  if (n < 2) stop("The data must contain at least two elements.")
  # Calculate the mean of X
  X_bar <- mean(X)
  # Compute the first term (A1)
  A1 <- sum((n - 1:(n - 1)) / n * log((n - 1:(n - 1)) / n) * (X[2:n] - X[1:(n - 1)]))
  # Compute the second term (A2)
  A2 <- sqrt(pi / 2) * sqrt(sum(X^3) / (3 * sum(X)))
  # Compute CK_n
  CKn <- (A1 + A2) / X_bar
  return(CKn)
}


## Meintanis and Iliopoulos test statistic
Ln <- function(X, parm, nu) {
  n <- length(X)
  data = X / parm  
  a= 2*sqrt(2)
  # Compute the double summation term
  term1 <- 0
  for (j in 1:n) {
    for (k in 1:n) {
      denom <- data[j] + data[k] + a
      term1 <- term1 + (1 / denom) +
        (data[j] + data[k]) / denom^2 +
        2 * (data[j] * data[k] + 2) / denom^3 +
        6 / denom^4 +
        24 / denom^5
    }
  }
  term1 <- sqrt(2) / n * term1
  # Compute the second summation term
  term2 <- 0
  for (j in 1:n) {
    denom <- data[j] + a
    term2 <- term2 + (1 / denom) + (data[j] / denom^2) + (2 / denom^3)
  }
  term2 <- -2 * sqrt(2) * term2
  # Compute the L value
  L <- n / a + term1 + term2
  return(L)
}

#########################################################
tqt = function(n, x, parm, nu) {
  s = 0; a = 0.5
  g = function(u) (-2*log(1-u))^(0.5*(1-a))
  # muhat = sqrt(sum(x^2)/(2*n))
  g = Vectorize(g)
  for(i in 1:n) {
    s = s + (x[i]^a)*(integrate(g, (i-1)/n, i/n)$value)
  }
  T02 = ((parm^(1-a))*s - (a*mean(x)) - (1-a)*parm*(sqrt(pi/2))) / (mean(x)*(a-1))
  return(T02)
}

AH = function(x, parm, nu){
  n <- length(x)
  #xx <- rrayleigh(n, parm)
  xx<-x/parm
  out = tqt(n, xx, parm, nu)
  return(out)
}

mltest = function(x,parm, nu){
  n <- length(x)
  a = 2*sqrt(2)
  # l_hat = sqrt(sum(x^2)/(2*n))
  y = x / parm
  ysy = outer(y, y, "+")
  ypy = outer(y, y, "*")
  trm1 = 1/(ysy+a)
  trm2 = ysy / (ysy+a)^2
  trm3 = (2*ypy+2) / (ysy+a)^3
  trm4 = (3*ysy) / (ysy+a)^4
  trm5 = 6 / (ysy+a)^5
  trm6 = 1 / (y+a)
  trm7 = y / (y+a)^2
  trm8 = 1 / (y+a)^3
  Mn = (n/a)+(sqrt(2)/n)*sum(trm1+trm2+trm3+trm4+trm5) - (2*sqrt(2))*sum(trm6+trm7+trm8)
  return(Mn)
}

MI = function(x, parm, nu){
  n <- length(x)
  #sigma_hat = sqrt(sum(x^2)/(2*n))
  # xx <- rrayleigh(n, parm)
  xx<-x/parm
  out = mltest(xx, parm, nu)
  return(out)
}

bktest = function(x){
  n <- length(x)
  Xdata = sort(x)
  X = c(Xdata[2:n], Xdata[n])
  Snn = (1:(n-1))/n
  CKn = (sum((1-Snn)*log(1-Snn)*(X[-n] - Xdata[-n])) + ((sqrt(pi/2))*(sqrt((sum(Xdata^3))/(3*sum(Xdata)) )))) / mean(Xdata)
  return(CKn)
}

BK = function(x, parm, nu){
  n <- length(x)
  #sigma_hat = sqrt(sum(x^2)/(2*n))
  # xx <- rrayleigh(n, parm)
  xx<-x/parm
  out = bktest(xx)
  return(out)
}

jrftest = function(x, parm, nu){
  n <- length(x)
  xneg = rep(NA, n)
  xpos = rep(NA, n)
  #l_hat = sqrt(sum(x^2)/(2*n))
  Xdata = sort(x)
  m = n - 5
  for (k in 1:n){
    neg = k - m
    xneg[k] = ifelse(neg < 1, Xdata[1], Xdata[neg])
    pos = k + m
    xpos[k] = ifelse(pos > n, Xdata[n], Xdata[pos])
  }
  vas = 1 / ((n / (2 * m)) * (xpos - xneg))
  f02 = (Xdata / (parm^2)) * exp(-Xdata^2 / (2 * (parm^2)))
  DHn = (1 / (2 * n)) * sum((sqrt(vas) - sqrt(f02))^2 / vas)
  return(DHn)
}

JH = function(x, parm, nu){
  n <- length(x)
  #sigma_hat = sqrt(sum(x^2)/(2*n))
  #xx <- rrayleigh(n, parm)
  xx<-x/parm
  out = jrftest(xx, parm, nu)
  return(out)
}


## Safavinejad et al test statistic
Rn <- function(X, parm, nu) {
  delta=0.5
  X<- X / parm  
  n <- length(X)
  if (delta <= 0 || delta >= 1) stop("Delta must be in the range (0, 1)")
  # Compute the numerator
  m_max <- floor(n^delta)
  numerator <- Inf  # Start with a very large value for minimization
  for (m in 1:m_max) {
    product_term <- 1
    for (j in 1:n) {
      if (j + m <= n && j - m > 0) {  # Ensure indices are within bounds
        product_term <- product_term * ((2 * m / n) * (X[j + m] - X[j - m]))
      }
    }
    numerator <- min(numerator, product_term)
  }
  # Compute the denominator
  denominator <- prod(X / (parm * sqrt(2 * n))) * exp(-sum(X^2) / (2 * parm^2))
  # Compute Rn
  Rn <- numerator / denominator
  return(Rn)
}

########################## Classical #######
KSn <- function(X, parm, nu) {
  n = length(X)
  FH = pchi_family(X, nu, parm)
  max(abs(c((1:n)/n - FH, FH - (0:(n-1))/n)))
}

CVn <- function(X, parm, nu) {
  n = length(X)
  FH = pchi_family(X, nu, parm)
  sum((FH - (2 * (1:n) - 1)/(2 * n))^2) + 1 / (12 * n)
}

ADn <- function(X, parm, nu) {
  n = length(X)
  z = pchi_family(X, nu, parm)
  -n - mean((2*(1:n)-1) * (log(z) + log(1 - z[n:1])))
}

MAn <- function(X, parm, nu) {
  n = length(X)
  z = pchi_family(X, nu, parm)
  n/2 - 2 * sum(z) - sum((2 - (2*(1:n) - 1)/n) * log(1 - z))
}

watson_U2_stat <- function(u) {
  n <- length(u); u_sorted <- sort(u)
  sum((u_sorted - (2*(1:n) - 1)/(2*n))^2) + 1 / (12*n)
}

Wn <- function(X, parm, nu) watson_U2_stat(pchi_family(X, nu, parm))

ZAn <- function(X, parm,nu, epsilon = 1e-4) {
  n = length(X)
  X[X == min(X)] <- X[X == min(X)] + epsilon
  j = 1:n
  FH =pchi_family(X, nu, parm)
  out = -sum(log(FH) / (n - j + 0.5) + log(1 - FH) / (j - 0.5))
  return(out)
}

ZBn <- function(X, parm, nu, epsilon = 1e-4) {
  n = length(X)
  X[X == min(X)] <- X[X == min(X)] + epsilon
  j = 1:n
  FH = pchi_family(X, nu, parm)
  arg = (1 / FH - 1) / ((n - 0.5) / (j - 0.75) - 1)
  out = sum((log(arg))^2)
  return(out)
}

ZCn <- function(X, parm, nu) {
  n = length(X)
  j = 1:n
  FH = pchi_family(X, nu, parm)
  T1 = n * (j - 0.5) / (n - j + 0.5)^2 * log((j - 0.5) / (n * FH))
  T2 = n / (n - j + 0.5) * log((n - j + 0.5) / (n * (1 - FH)))
  out = 2 * sum(T1 + T2)
  return(out)
}

###############################################################################
rEV <- function(n,parm){
  X = log(1-parm*log(1-runif(n)))
  return(X)
}
rLFR <- function(n,parm){
  U = runif(n)
  X = (-1+sqrt(1-2*parm*log(1-U)))/parm
  return(X)
}
rBE <- function(n,parm){
  B = rbeta(n,parm,1)
  X = -log(1-B)
  return(X)
}
rInvBeta <- function(n,parm){
  U = runif(n)
  X = 1/(1-U^(1/(parm+1)))
  return(X)
}

rTiltedPareto <- function(n,parm){
  out = (1+parm)/(1-runif(n))-parm
  return(out)
}
rBenini <- function(n,parm){
  U = runif(n)
  X = exp((-1+sqrt(1-4*parm*log(1-U)))/(2*parm))
  return(X)
}
dBenini <- function(x,parm){
  T1  = exp(-parm*(log(x))^2)/x^2
  T2  = 1+2*parm*log(x)
  out = T1*T2
  return(out)
}
# Chen's:
rChen <- function(n,parm){
  X = log(1-0.5*log(1-runif(n)))^(1/parm)
  return(X)
}

# Extreme Value:
rEV <- function(n,parm){
  X = log(1-parm*log(1-runif(n)))
  return(X)
}
# ========== Alternative Distributions ========== #
r_alternatives <- list(
  Ray1 = function(n) rrayleigh(n, 0.5),
  Ray2 = function(n) rrayleigh(n, 1),
  Ray3 = function(n) rrayleigh(n, 3),
  
  Halfnormal_1 = function(n) rhalfnormal(n, 1),
  Halfnormal_3 = function(n) rhalfnormal(n, 3),
  
  max1=function(n) rmaxwell(n,1),
  max2=function(n) rmaxwell(n,3),
  max3=function(n) rmaxwell(n,5),
  
  Ev1=function(n) rEV(n,1),
  Ev2=function(n) rEV(n,2),
  
  Ch1  = function(n) rChen(n, 1),
  Ch2  = function(n) rChen(n, 2),
  
  LF1=function(n) rLFR(n, 1),
  LF2=function(n) rLFR(n, 2),

  
  ChiSq_1 = function(n) rchisq(n, 1),
  ChiSq_2 = function(n) rchisq(n, 3),
  ChiSq_3 = function(n) rchisq(n, 5),
  
  Gamma_1 = function(n) rgamma(n, 0.5, 1),
  Gamma_2 = function(n) rgamma(n, 1, 1),
  Gamma_3 = function(n) rgamma(n, 1, 3),
  
  InvGauss_1 = function(n) rinvgauss(n, 2, 1),
  InvGauss_2 = function(n) rinvgauss(n, 2, 3),
  InvGauss_3 = function(n) rinvgauss(n, 3, 2),
  
  InvGamma_1 = function(n) rinvgamma(n, 1.5, 1),
  InvGamma_2 = function(n) rinvgamma(n, 3, 1),
  InvGamma_3 = function(n) rinvgamma(n, 3.0, 5),
  
  Weibull_1 = function(n) rweibull(n, 0.7, 1),
  Weibull_2 = function(n) rweibull(n, 1, 1),
  Weibull_3 = function(n) rweibull(n, 2.0, 0.5) 
  
)


# ========== Simulation Parameters ========== #
#set.seed(1234)
n_values <- c(25, 50)
MC <- 100000   
nu_values <- 2  #  Rayleigh   
a_values <- c(0.5, 1, 1.5)

# ========== Simulation Loop ========== #
results <- list()

for (nu in nu_values) {
  for (n in n_values) {
    #cat("Running for nu =", nu, "n =", n, "\n")
    mac <- matrix(0, nrow = length(r_alternatives), ncol = 18)
    rownames(mac) <- names(r_alternatives)
    colnames(mac) <- c("Tn(0.5)", "Tn(1)","Tn(1.5)","CKn","Ln","AH","MI", "BK", "JH", "Rn", "KSn", "CVn", "ADn", "MAn", 
                       "Wn", "ZAn","ZBn","ZCn" )
    
    for (alt in names(r_alternatives)) {
      s.mat <- matrix(0, nrow = MC, ncol = 18)
      s.boot <- matrix(0, nrow = MC, ncol = 18)
      
      for (i in 1:MC) {
        x <- r_alternatives[[alt]](n)
        x.boot <- rchi_family(n, nu)
        
        mu <- estimation(x)
        mu.boot <- estimation(x.boot)
        
        s.mat[i,1] <- Tn(x, mu, a_values[1], nu)
        s.boot[i,1] <- Tn(x.boot, mu.boot, a_values[1], nu)
        
        s.mat[i,2] <- Tn(x, mu, a_values[2], nu)
        s.boot[i,2] <- Tn(x.boot, mu.boot, a_values[2], nu)
        
        s.mat[i,3] <- Tn(x, mu, a_values[3], nu)
        s.boot[i,3] <- Tn(x.boot, mu.boot, a_values[3], nu)
        
        s.mat[i,4]<- CKn(x,mu, nu)
        s.boot[i,4]<- CKn(x.boot,mu.boot, nu)
        
        s.mat[i,5]<- Ln(x,mu, nu)
        s.boot[i,5]<- Ln(x.boot,mu.boot, nu)
        
        s.mat[i,6] <- AH(x, mu, nu)
        s.boot[i,6] <- AH(x.boot, mu.boot, nu)
        
        s.mat[i,7] <- MI(x, mu, nu)
        s.boot[i,7] <- MI(x.boot, mu.boot, nu)
        
        s.mat[i,8] <- BK(x, mu, nu)
        s.boot[i,8] <- BK(x.boot, mu.boot, nu)
        
        s.mat[i,9] <- JH(x, mu, nu)
        s.boot[i,9] <- JH(x.boot, mu.boot, nu)
        
        s.mat[i,10]<- Rn(x,mu, nu)
        s.boot[i,10]<- Rn(x.boot,mu.boot, nu)
        
        s.mat[i,11]<- KSn(x, mu, nu)
        s.boot[i,11]<- KSn(x.boot,mu.boot, nu)
        
        s.mat[i,12]<- CVn(x, mu, nu)
        s.boot[i,12]<-CVn(x.boot,mu.boot, nu)
        
        s.mat[i,13]<- ADn(x, mu, nu)
        s.boot[i,13]<-ADn(x.boot,mu.boot, nu)
        
        s.mat[i,14]<- MAn(x, mu, nu)
        s.boot[i,14]<- MAn(x.boot,mu.boot, nu)
        
        s.mat[i,15]<- Wn(x, mu, nu)
        s.boot[i,15]<- Wn(x.boot,mu.boot, nu)   
        
        s.mat[i,16]<- ZAn(x,mu, nu)
        s.boot[i,16]<- ZAn(x.boot,mu.boot, nu)    
        
        s.mat[i,17]<- ZBn(x,mu, nu)
        s.boot[i,17]<-  ZBn(x.boot,mu.boot, nu)
        
        s.mat[i,18]<- ZCn(x,mu, nu)
        s.boot[i,18]<- ZCn(x.boot,mu.boot, nu) 
        
      }
      
      # Compute empirical power
      for (j in 1:11)
        mac[alt, j] <- mean(s.mat[, j] > quantile(s.boot[, j], 0.95), na.rm = TRUE)
    }
    
    results[[paste0("nu", nu, "_n", n)]] <- round(mac, 3)
  }
}
results[["nu2_n25"]]   
results[["nu2_n50"]]   

